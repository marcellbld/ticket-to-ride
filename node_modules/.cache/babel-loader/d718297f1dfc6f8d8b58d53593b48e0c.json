{"ast":null,"code":"import { CardStates } from \"../../domain/card\";\nimport { Colors } from \"../../domain/colors\";\nimport { REMOVE_CARD_FROM_PLAYER, SET_DECK, UPDATE_CARD } from \"./actions\";\nconst initialState = [];\nexport function deckReducer() {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  const {\n    type,\n    payload\n  } = action;\n  switch (type) {\n    case SET_DECK:\n      return payload;\n    case UPDATE_CARD:\n      return updateCard(state, payload);\n    case REMOVE_CARD_FROM_PLAYER:\n      const {\n        playerId,\n        color,\n        amount\n      } = payload;\n      return removeCardFromPlayer(state, playerId, color, amount);\n    default:\n      return state;\n  }\n}\nfunction refreshPublicCards(deck) {\n  let newDeck = [...deck];\n  let publicCards = newDeck.filter(card => CardStates.PUBLIC.includes(card.cardState));\n  for (let i = 0; i < CardStates.PUBLIC.length; i++) {\n    if (!publicCards.some(card => card.cardState === CardStates.PUBLIC[i])) {\n      for (let card of newDeck) {\n        if (card.cardState === CardStates.DECK) {\n          card.cardState = CardStates.PUBLIC[i];\n          publicCards.push(card);\n          break;\n        }\n      }\n    }\n  }\n  if (publicCards.filter(card => card.color === Colors.LOCOMOTIVE).length >= 3) {\n    newDeck = newDeck.map(card => {\n      if (CardStates.PUBLIC.includes(card.cardState)) return {\n        ...card,\n        cardState: CardStates.REMOVED\n      };\n      return card;\n    });\n    return refreshPublicCards(newDeck);\n  }\n  return newDeck;\n}\nfunction updateCard(deck, updatedCard) {\n  let isPublicCard = false;\n  let updatedDeck = deck.map(card => {\n    if (card.id === updatedCard.id) {\n      if (card.cardState <= CardStates.PUBLIC[0]) {\n        isPublicCard = true;\n      }\n      return updatedCard;\n    } else {\n      return card;\n    }\n  });\n  if (isPublicCard) {\n    updatedDeck = refreshPublicCards(updatedDeck);\n  }\n  return updatedDeck;\n}\nfunction removeCardFromPlayer(deck, playerId, color, amount) {\n  let updatedCards = 0;\n  let updatedDeck = deck.map(card => {\n    if (updatedCards < amount && card.cardState === playerId && card.color === color) {\n      updatedCards++;\n      return {\n        ...card,\n        cardState: CardStates.REMOVED\n      };\n    }\n    return card;\n  });\n  return updatedDeck;\n}","map":{"version":3,"names":["CardStates","Colors","REMOVE_CARD_FROM_PLAYER","SET_DECK","UPDATE_CARD","initialState","deckReducer","state","action","type","payload","updateCard","playerId","color","amount","removeCardFromPlayer","refreshPublicCards","deck","newDeck","publicCards","filter","card","PUBLIC","includes","cardState","i","length","some","DECK","push","LOCOMOTIVE","map","REMOVED","updatedCard","isPublicCard","updatedDeck","id","updatedCards"],"sources":["C:/Win11/Programming/Other/ticket-to-ride-app/src/state/deck/reducer.js"],"sourcesContent":["import { CardStates } from \"../../domain/card\";\r\nimport { Colors } from \"../../domain/colors\";\r\nimport { REMOVE_CARD_FROM_PLAYER, SET_DECK, UPDATE_CARD } from \"./actions\";\r\n\r\nconst initialState = [];\r\nexport function deckReducer(state = initialState, action) {\r\n  const { type, payload } = action;\r\n  switch (type) {\r\n    case SET_DECK:\r\n      return payload;\r\n    case UPDATE_CARD:\r\n      return updateCard(state, payload);\r\n    case REMOVE_CARD_FROM_PLAYER:\r\n      const { playerId, color, amount } = payload;\r\n      return removeCardFromPlayer(state, playerId, color, amount);\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction refreshPublicCards(deck) {\r\n  let newDeck = [...deck];\r\n  let publicCards = newDeck.filter((card) =>\r\n    CardStates.PUBLIC.includes(card.cardState)\r\n  );\r\n\r\n  for (let i = 0; i < CardStates.PUBLIC.length; i++) {\r\n    if (!publicCards.some((card) => card.cardState === CardStates.PUBLIC[i])) {\r\n      for (let card of newDeck) {\r\n        if (card.cardState === CardStates.DECK) {\r\n          card.cardState = CardStates.PUBLIC[i];\r\n          publicCards.push(card);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (\r\n    publicCards.filter((card) => card.color === Colors.LOCOMOTIVE).length >= 3\r\n  ) {\r\n    newDeck = newDeck.map((card) => {\r\n      if (CardStates.PUBLIC.includes(card.cardState))\r\n        return {...card, cardState: CardStates.REMOVED};\r\n\r\n      return card;\r\n    });\r\n    return refreshPublicCards(newDeck);\r\n  }\r\n\r\n  return newDeck;\r\n}\r\n\r\nfunction updateCard(deck, updatedCard) {\r\n  let isPublicCard = false;\r\n  let updatedDeck = deck.map((card) => {\r\n    if (card.id === updatedCard.id) {\r\n      if (card.cardState <= CardStates.PUBLIC[0]) {\r\n        isPublicCard = true;\r\n      }\r\n      return updatedCard;\r\n    } else {\r\n      return card;\r\n    }\r\n  });\r\n  if (isPublicCard) {\r\n    updatedDeck = refreshPublicCards(updatedDeck);\r\n  }\r\n\r\n  return updatedDeck;\r\n}\r\n\r\nfunction removeCardFromPlayer(deck, playerId, color, amount) {\r\n  let updatedCards = 0;\r\n  let updatedDeck = deck.map((card) => {\r\n    if (\r\n      updatedCards < amount &&\r\n      card.cardState === playerId &&\r\n      card.color === color\r\n    ) {\r\n      updatedCards++;\r\n      return { ...card, cardState: CardStates.REMOVED };\r\n    }\r\n    return card;\r\n  });\r\n  return updatedDeck;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}