{"ast":null,"code":"import { ticketToRideData } from \"../data/ticket-to-ride-data\";\nexport function findPathBetweenCities(startCityId, builtConnections) {\n  const citiesPI = new Array(Object.values(ticketToRideData.cities).length + 1).fill(0);\n  const citiesD = new Array(Object.values(ticketToRideData.cities).length + 1).fill(100);\n  const checkedEdges = [];\n  const queue = [];\n  queue.push(startCityId);\n  citiesD[startCityId] = 0;\n  while (queue.length > 0) {\n    const currCity = queue[0];\n    for (let connectionId of builtConnections) {\n      if (checkedEdges.includes(connectionId)) continue;\n      const connection = ticketToRideData.connections[connectionId];\n      if (connection.from === currCity || connection.to === currCity) {\n        const from = connection.from === currCity;\n        const cityId = from ? connection.to : connection.from;\n        if (citiesD[cityId] === 100 || citiesD[cityId] < citiesD[currCity]) {\n          citiesD[cityId] = citiesD[currCity] + 1;\n          citiesPI[cityId] = currCity;\n          queue.push(cityId);\n        }\n        checkedEdges.push(connectionId);\n      }\n    }\n    queue.shift();\n  }\n  return {\n    pi: citiesPI,\n    d: citiesD\n  };\n}\nexport function hasConnectionBetweenCities(startCityId, endCityId, builtConnections) {\n  const {\n    pi,\n    d\n  } = findPathBetweenCities(startCityId, builtConnections);\n  let completed = false;\n  if (d[endCityId] !== 100) {\n    let city = endCityId;\n    while (city !== 0 && city !== startCityId) {\n      city = pi[city];\n    }\n    if (city === startCityId) {\n      completed = true;\n    }\n  }\n  return completed;\n}","map":{"version":3,"names":["ticketToRideData","findPathBetweenCities","startCityId","builtConnections","citiesPI","Array","Object","values","cities","length","fill","citiesD","checkedEdges","queue","push","currCity","connectionId","includes","connection","connections","from","to","cityId","shift","pi","d","hasConnectionBetweenCities","endCityId","completed","city"],"sources":["C:/Win11/Programming/Other/ticket-to-ride-app/src/util/pathfinder.js"],"sourcesContent":["import { ticketToRideData } from \"../data/ticket-to-ride-data\";\r\n\r\nexport function findPathBetweenCities(startCityId, builtConnections) {\r\n  const citiesPI = new Array(\r\n    Object.values(ticketToRideData.cities).length + 1\r\n  ).fill(0);\r\n  const citiesD = new Array(\r\n    Object.values(ticketToRideData.cities).length + 1\r\n  ).fill(100);\r\n\r\n  const checkedEdges = [];\r\n  const queue = [];\r\n  queue.push(startCityId);\r\n  citiesD[startCityId] = 0;\r\n\r\n  while (queue.length > 0) {\r\n    const currCity = queue[0];\r\n\r\n    for (let connectionId of builtConnections) {\r\n      if (checkedEdges.includes(connectionId)) continue;\r\n\r\n      const connection = ticketToRideData.connections[connectionId];\r\n\r\n      if (connection.from === currCity || connection.to === currCity) {\r\n        const from = connection.from === currCity;\r\n        const cityId = from ? connection.to : connection.from;\r\n        if (citiesD[cityId] === 100 || citiesD[cityId] < citiesD[currCity]) {\r\n          citiesD[cityId] = citiesD[currCity] + 1;\r\n          citiesPI[cityId] = currCity;\r\n          queue.push(cityId);\r\n        }\r\n\r\n        checkedEdges.push(connectionId);\r\n      }\r\n    }\r\n    queue.shift();\r\n  }\r\n\r\n  return { pi: citiesPI, d: citiesD };\r\n}\r\n\r\nexport function hasConnectionBetweenCities(\r\n  startCityId,\r\n  endCityId,\r\n  builtConnections\r\n) {\r\n  const { pi, d } = findPathBetweenCities(startCityId, builtConnections);\r\n  let completed = false;\r\n  if (d[endCityId] !== 100) {\r\n    let city = endCityId;\r\n    while (city !== 0 && city !== startCityId) {\r\n      city = pi[city];\r\n    }\r\n    if (city === startCityId) {\r\n      completed = true;\r\n    }\r\n  }\r\n\r\n  return completed;\r\n}\r\n"],"mappings":"AAAA,SAASA,gBAAgB,QAAQ,6BAA6B;AAE9D,OAAO,SAASC,qBAAqB,CAACC,WAAW,EAAEC,gBAAgB,EAAE;EACnE,MAAMC,QAAQ,GAAG,IAAIC,KAAK,CACxBC,MAAM,CAACC,MAAM,CAACP,gBAAgB,CAACQ,MAAM,CAAC,CAACC,MAAM,GAAG,CAAC,CAClD,CAACC,IAAI,CAAC,CAAC,CAAC;EACT,MAAMC,OAAO,GAAG,IAAIN,KAAK,CACvBC,MAAM,CAACC,MAAM,CAACP,gBAAgB,CAACQ,MAAM,CAAC,CAACC,MAAM,GAAG,CAAC,CAClD,CAACC,IAAI,CAAC,GAAG,CAAC;EAEX,MAAME,YAAY,GAAG,EAAE;EACvB,MAAMC,KAAK,GAAG,EAAE;EAChBA,KAAK,CAACC,IAAI,CAACZ,WAAW,CAAC;EACvBS,OAAO,CAACT,WAAW,CAAC,GAAG,CAAC;EAExB,OAAOW,KAAK,CAACJ,MAAM,GAAG,CAAC,EAAE;IACvB,MAAMM,QAAQ,GAAGF,KAAK,CAAC,CAAC,CAAC;IAEzB,KAAK,IAAIG,YAAY,IAAIb,gBAAgB,EAAE;MACzC,IAAIS,YAAY,CAACK,QAAQ,CAACD,YAAY,CAAC,EAAE;MAEzC,MAAME,UAAU,GAAGlB,gBAAgB,CAACmB,WAAW,CAACH,YAAY,CAAC;MAE7D,IAAIE,UAAU,CAACE,IAAI,KAAKL,QAAQ,IAAIG,UAAU,CAACG,EAAE,KAAKN,QAAQ,EAAE;QAC9D,MAAMK,IAAI,GAAGF,UAAU,CAACE,IAAI,KAAKL,QAAQ;QACzC,MAAMO,MAAM,GAAGF,IAAI,GAAGF,UAAU,CAACG,EAAE,GAAGH,UAAU,CAACE,IAAI;QACrD,IAAIT,OAAO,CAACW,MAAM,CAAC,KAAK,GAAG,IAAIX,OAAO,CAACW,MAAM,CAAC,GAAGX,OAAO,CAACI,QAAQ,CAAC,EAAE;UAClEJ,OAAO,CAACW,MAAM,CAAC,GAAGX,OAAO,CAACI,QAAQ,CAAC,GAAG,CAAC;UACvCX,QAAQ,CAACkB,MAAM,CAAC,GAAGP,QAAQ;UAC3BF,KAAK,CAACC,IAAI,CAACQ,MAAM,CAAC;QACpB;QAEAV,YAAY,CAACE,IAAI,CAACE,YAAY,CAAC;MACjC;IACF;IACAH,KAAK,CAACU,KAAK,EAAE;EACf;EAEA,OAAO;IAAEC,EAAE,EAAEpB,QAAQ;IAAEqB,CAAC,EAAEd;EAAQ,CAAC;AACrC;AAEA,OAAO,SAASe,0BAA0B,CACxCxB,WAAW,EACXyB,SAAS,EACTxB,gBAAgB,EAChB;EACA,MAAM;IAAEqB,EAAE;IAAEC;EAAE,CAAC,GAAGxB,qBAAqB,CAACC,WAAW,EAAEC,gBAAgB,CAAC;EACtE,IAAIyB,SAAS,GAAG,KAAK;EACrB,IAAIH,CAAC,CAACE,SAAS,CAAC,KAAK,GAAG,EAAE;IACxB,IAAIE,IAAI,GAAGF,SAAS;IACpB,OAAOE,IAAI,KAAK,CAAC,IAAIA,IAAI,KAAK3B,WAAW,EAAE;MACzC2B,IAAI,GAAGL,EAAE,CAACK,IAAI,CAAC;IACjB;IACA,IAAIA,IAAI,KAAK3B,WAAW,EAAE;MACxB0B,SAAS,GAAG,IAAI;IAClB;EACF;EAEA,OAAOA,SAAS;AAClB"},"metadata":{},"sourceType":"module"}